// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/pathomove.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// get_test_landscape
Rcpp::DataFrame get_test_landscape(const int nItems, const float landsize, const int nClusters, const float clusterSpread, const int regen_time);
static SEXP _pathomove_get_test_landscape_try(SEXP nItemsSEXP, SEXP landsizeSEXP, SEXP nClustersSEXP, SEXP clusterSpreadSEXP, SEXP regen_timeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type nItems(nItemsSEXP);
    Rcpp::traits::input_parameter< const float >::type landsize(landsizeSEXP);
    Rcpp::traits::input_parameter< const int >::type nClusters(nClustersSEXP);
    Rcpp::traits::input_parameter< const float >::type clusterSpread(clusterSpreadSEXP);
    Rcpp::traits::input_parameter< const int >::type regen_time(regen_timeSEXP);
    rcpp_result_gen = Rcpp::wrap(get_test_landscape(nItems, landsize, nClusters, clusterSpread, regen_time));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _pathomove_get_test_landscape(SEXP nItemsSEXP, SEXP landsizeSEXP, SEXP nClustersSEXP, SEXP clusterSpreadSEXP, SEXP regen_timeSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_pathomove_get_test_landscape_try(nItemsSEXP, landsizeSEXP, nClustersSEXP, clusterSpreadSEXP, regen_timeSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// run_pathomove
Rcpp::S4 run_pathomove(const int scenario, const int popsize, const int nItems, const float landsize, const int nClusters, const float clusterSpread, const int tmax, const int genmax, const int g_patho_init, const int n_samples, const float range_food, const float range_agents, const float range_move, const int handling_time, const int regen_time, float pTransmit, const float p_v_transmit, const int initialInfections, const float costInfect, const bool multithreaded, const float dispersal, const bool infect_percent, const bool vertical, const bool reprod_threshold, const float mProb, const float mSize, const float spillover_rate, const int seed);
static SEXP _pathomove_run_pathomove_try(SEXP scenarioSEXP, SEXP popsizeSEXP, SEXP nItemsSEXP, SEXP landsizeSEXP, SEXP nClustersSEXP, SEXP clusterSpreadSEXP, SEXP tmaxSEXP, SEXP genmaxSEXP, SEXP g_patho_initSEXP, SEXP n_samplesSEXP, SEXP range_foodSEXP, SEXP range_agentsSEXP, SEXP range_moveSEXP, SEXP handling_timeSEXP, SEXP regen_timeSEXP, SEXP pTransmitSEXP, SEXP p_v_transmitSEXP, SEXP initialInfectionsSEXP, SEXP costInfectSEXP, SEXP multithreadedSEXP, SEXP dispersalSEXP, SEXP infect_percentSEXP, SEXP verticalSEXP, SEXP reprod_thresholdSEXP, SEXP mProbSEXP, SEXP mSizeSEXP, SEXP spillover_rateSEXP, SEXP seedSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type scenario(scenarioSEXP);
    Rcpp::traits::input_parameter< const int >::type popsize(popsizeSEXP);
    Rcpp::traits::input_parameter< const int >::type nItems(nItemsSEXP);
    Rcpp::traits::input_parameter< const float >::type landsize(landsizeSEXP);
    Rcpp::traits::input_parameter< const int >::type nClusters(nClustersSEXP);
    Rcpp::traits::input_parameter< const float >::type clusterSpread(clusterSpreadSEXP);
    Rcpp::traits::input_parameter< const int >::type tmax(tmaxSEXP);
    Rcpp::traits::input_parameter< const int >::type genmax(genmaxSEXP);
    Rcpp::traits::input_parameter< const int >::type g_patho_init(g_patho_initSEXP);
    Rcpp::traits::input_parameter< const int >::type n_samples(n_samplesSEXP);
    Rcpp::traits::input_parameter< const float >::type range_food(range_foodSEXP);
    Rcpp::traits::input_parameter< const float >::type range_agents(range_agentsSEXP);
    Rcpp::traits::input_parameter< const float >::type range_move(range_moveSEXP);
    Rcpp::traits::input_parameter< const int >::type handling_time(handling_timeSEXP);
    Rcpp::traits::input_parameter< const int >::type regen_time(regen_timeSEXP);
    Rcpp::traits::input_parameter< float >::type pTransmit(pTransmitSEXP);
    Rcpp::traits::input_parameter< const float >::type p_v_transmit(p_v_transmitSEXP);
    Rcpp::traits::input_parameter< const int >::type initialInfections(initialInfectionsSEXP);
    Rcpp::traits::input_parameter< const float >::type costInfect(costInfectSEXP);
    Rcpp::traits::input_parameter< const bool >::type multithreaded(multithreadedSEXP);
    Rcpp::traits::input_parameter< const float >::type dispersal(dispersalSEXP);
    Rcpp::traits::input_parameter< const bool >::type infect_percent(infect_percentSEXP);
    Rcpp::traits::input_parameter< const bool >::type vertical(verticalSEXP);
    Rcpp::traits::input_parameter< const bool >::type reprod_threshold(reprod_thresholdSEXP);
    Rcpp::traits::input_parameter< const float >::type mProb(mProbSEXP);
    Rcpp::traits::input_parameter< const float >::type mSize(mSizeSEXP);
    Rcpp::traits::input_parameter< const float >::type spillover_rate(spillover_rateSEXP);
    Rcpp::traits::input_parameter< const int >::type seed(seedSEXP);
    rcpp_result_gen = Rcpp::wrap(run_pathomove(scenario, popsize, nItems, landsize, nClusters, clusterSpread, tmax, genmax, g_patho_init, n_samples, range_food, range_agents, range_move, handling_time, regen_time, pTransmit, p_v_transmit, initialInfections, costInfect, multithreaded, dispersal, infect_percent, vertical, reprod_threshold, mProb, mSize, spillover_rate, seed));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _pathomove_run_pathomove(SEXP scenarioSEXP, SEXP popsizeSEXP, SEXP nItemsSEXP, SEXP landsizeSEXP, SEXP nClustersSEXP, SEXP clusterSpreadSEXP, SEXP tmaxSEXP, SEXP genmaxSEXP, SEXP g_patho_initSEXP, SEXP n_samplesSEXP, SEXP range_foodSEXP, SEXP range_agentsSEXP, SEXP range_moveSEXP, SEXP handling_timeSEXP, SEXP regen_timeSEXP, SEXP pTransmitSEXP, SEXP p_v_transmitSEXP, SEXP initialInfectionsSEXP, SEXP costInfectSEXP, SEXP multithreadedSEXP, SEXP dispersalSEXP, SEXP infect_percentSEXP, SEXP verticalSEXP, SEXP reprod_thresholdSEXP, SEXP mProbSEXP, SEXP mSizeSEXP, SEXP spillover_rateSEXP, SEXP seedSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_pathomove_run_pathomove_try(scenarioSEXP, popsizeSEXP, nItemsSEXP, landsizeSEXP, nClustersSEXP, clusterSpreadSEXP, tmaxSEXP, genmaxSEXP, g_patho_initSEXP, n_samplesSEXP, range_foodSEXP, range_agentsSEXP, range_moveSEXP, handling_timeSEXP, regen_timeSEXP, pTransmitSEXP, p_v_transmitSEXP, initialInfectionsSEXP, costInfectSEXP, multithreadedSEXP, dispersalSEXP, infect_percentSEXP, verticalSEXP, reprod_thresholdSEXP, mProbSEXP, mSizeSEXP, spillover_rateSEXP, seedSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _pathomove_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("Rcpp::DataFrame(*get_test_landscape)(const int,const float,const int,const float,const int)");
        signatures.insert("Rcpp::S4(*run_pathomove)(const int,const int,const int,const float,const int,const float,const int,const int,const int,const int,const float,const float,const float,const int,const int,float,const float,const int,const float,const bool,const float,const bool,const bool,const bool,const float,const float,const float,const int)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _pathomove_RcppExport_registerCCallable() { 
    R_RegisterCCallable("pathomove", "_pathomove_get_test_landscape", (DL_FUNC)_pathomove_get_test_landscape_try);
    R_RegisterCCallable("pathomove", "_pathomove_run_pathomove", (DL_FUNC)_pathomove_run_pathomove_try);
    R_RegisterCCallable("pathomove", "_pathomove_RcppExport_validate", (DL_FUNC)_pathomove_RcppExport_validate);
    return R_NilValue;
}

RcppExport SEXP run_testthat_tests(SEXP);

static const R_CallMethodDef CallEntries[] = {
    {"_pathomove_get_test_landscape", (DL_FUNC) &_pathomove_get_test_landscape, 5},
    {"_pathomove_run_pathomove", (DL_FUNC) &_pathomove_run_pathomove, 28},
    {"_pathomove_RcppExport_registerCCallable", (DL_FUNC) &_pathomove_RcppExport_registerCCallable, 0},
    {"run_testthat_tests", (DL_FUNC) &run_testthat_tests, 1},
    {NULL, NULL, 0}
};

RcppExport void R_init_pathomove(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
